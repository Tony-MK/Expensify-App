"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const react_native_onyx_1 = require("react-native-onyx");
const App_1 = require("@libs/actions/App");
const OnyxUpdateManager_1 = require("@libs/actions/OnyxUpdateManager");
const PersistedRequests_1 = require("@libs/actions/PersistedRequests");
// eslint-disable-next-line no-restricted-syntax
const SignInRedirect = require("@libs/actions/SignInRedirect");
const types_1 = require("@libs/API/types");
const asyncOpenURL_1 = require("@libs/asyncOpenURL");
const HttpUtils_1 = require("@libs/HttpUtils");
const PushNotification_1 = require("@libs/Notification/PushNotification");
// This lib needs to be imported, but it has nothing to export since all it contains is an Onyx connection
require("@libs/Notification/PushNotification/subscribeToPushNotifications");
const CONFIG_1 = require("@src/CONFIG");
const CONST_1 = require("@src/CONST");
const SessionUtil = require("@src/libs/actions/Session");
const Session_1 = require("@src/libs/actions/Session");
const ONYXKEYS_1 = require("@src/ONYXKEYS");
const TestHelper = require("../utils/TestHelper");
const waitForBatchedUpdates_1 = require("../utils/waitForBatchedUpdates");
// We are mocking this method so that we can later test to see if it was called and what arguments it was called with.
// We test HttpUtils.xhr() since this means that our API command turned into a network request and isn't only queued.
HttpUtils_1.default.xhr = globals_1.jest.fn();
// Mocked to ensure push notifications are subscribed/unsubscribed as the session changes
globals_1.jest.mock('@libs/Notification/PushNotification');
// Mocked to check SignOutAndRedirectToSignIn behavior
globals_1.jest.mock('@libs/asyncOpenURL');
react_native_onyx_1.default.init({
    keys: ONYXKEYS_1.default,
});
(0, OnyxUpdateManager_1.default)();
(0, globals_1.beforeEach)(() => react_native_onyx_1.default.clear().then(waitForBatchedUpdates_1.default));
describe('Session', () => {
    (0, globals_1.test)('Authenticate is called with saved credentials when a session expires', async () => {
        // Given a test user and set of authToken with subscriptions to session and credentials
        const TEST_USER_LOGIN = 'test@testguy.com';
        const TEST_USER_ACCOUNT_ID = 1;
        const TEST_INITIAL_AUTH_TOKEN = 'initialAuthToken';
        const TEST_REFRESHED_AUTH_TOKEN = 'refreshedAuthToken';
        let credentials;
        react_native_onyx_1.default.connect({
            key: ONYXKEYS_1.default.CREDENTIALS,
            callback: (val) => (credentials = val),
        });
        let session;
        react_native_onyx_1.default.connect({
            key: ONYXKEYS_1.default.SESSION,
            callback: (val) => (session = val),
        });
        // When we sign in with the test user
        await TestHelper.signInWithTestUser(TEST_USER_ACCOUNT_ID, TEST_USER_LOGIN, 'Password1', TEST_INITIAL_AUTH_TOKEN);
        await (0, waitForBatchedUpdates_1.default)();
        // Then our re-authentication credentials should be generated and our session data
        // have the correct information + initial authToken.
        expect(credentials?.login).toBe(TEST_USER_LOGIN);
        expect(credentials?.autoGeneratedLogin).not.toBeUndefined();
        expect(credentials?.autoGeneratedPassword).not.toBeUndefined();
        expect(session?.authToken).toBe(TEST_INITIAL_AUTH_TOKEN);
        expect(session?.accountID).toBe(TEST_USER_ACCOUNT_ID);
        expect(session?.email).toBe(TEST_USER_LOGIN);
        // At this point we have an authToken. To simulate it expiring we'll just make another
        // request and mock the response so it returns 407. Once this happens we should attempt
        // to Re-Authenticate with the stored credentials. Our next call will be to Authenticate
        // so we will mock that response with a new authToken and then verify that Onyx has our
        // data.
        HttpUtils_1.default.xhr
            // This will make the call to OpenApp below return with an expired session code
            .mockImplementationOnce(() => Promise.resolve({
            jsonCode: CONST_1.default.JSON_CODE.NOT_AUTHENTICATED,
        }))
            // The next call should be Authenticate since we are re-authenticating
            .mockImplementationOnce(() => Promise.resolve({
            jsonCode: CONST_1.default.JSON_CODE.SUCCESS,
            accountID: TEST_USER_ACCOUNT_ID,
            authToken: TEST_REFRESHED_AUTH_TOKEN,
            email: TEST_USER_LOGIN,
        }));
        // When we attempt to fetch the initial app data via the API
        (0, App_1.confirmReadyToOpenApp)();
        (0, App_1.openApp)();
        await (0, waitForBatchedUpdates_1.default)();
        // Then it should fail and reauthenticate the user adding the new authToken to the session
        // data in Onyx
        expect(session?.authToken).toBe(TEST_REFRESHED_AUTH_TOKEN);
    });
    (0, globals_1.test)('Push notifications are subscribed after signing in', async () => {
        await TestHelper.signInWithTestUser();
        await (0, waitForBatchedUpdates_1.default)();
        expect(PushNotification_1.default.register).toBeCalled();
    });
    (0, globals_1.test)('Push notifications are unsubscribed after signing out', async () => {
        await TestHelper.signInWithTestUser();
        await TestHelper.signOutTestUser();
        expect(PushNotification_1.default.deregister).toBeCalled();
    });
    (0, globals_1.test)('ReconnectApp should push request to the queue', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.HAS_LOADED_APP, true);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        (0, App_1.confirmReadyToOpenApp)();
        (0, App_1.reconnectApp)();
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(1);
        expect((0, PersistedRequests_1.getAll)().at(0)?.command).toBe(types_1.WRITE_COMMANDS.RECONNECT_APP);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('ReconnectApp should open if app is not loaded', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.HAS_LOADED_APP, false);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        (0, App_1.confirmReadyToOpenApp)();
        (0, App_1.reconnectApp)();
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(1);
        expect((0, PersistedRequests_1.getAll)().at(0)?.command).toBe(types_1.WRITE_COMMANDS.OPEN_APP);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('ReconnectApp should replace same requests from the queue', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.HAS_LOADED_APP, true);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        (0, App_1.confirmReadyToOpenApp)();
        (0, App_1.reconnectApp)();
        (0, App_1.reconnectApp)();
        (0, App_1.reconnectApp)();
        (0, App_1.reconnectApp)();
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(1);
        expect((0, PersistedRequests_1.getAll)().at(0)?.command).toBe(types_1.WRITE_COMMANDS.RECONNECT_APP);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('OpenApp should push request to the queue', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        (0, App_1.openApp)();
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(1);
        expect((0, PersistedRequests_1.getAll)().at(0)?.command).toBe(types_1.WRITE_COMMANDS.OPEN_APP);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('OpenApp should replace same requests from the queue', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        (0, App_1.openApp)();
        (0, App_1.openApp)();
        (0, App_1.openApp)();
        (0, App_1.openApp)();
        await (0, waitForBatchedUpdates_1.default)();
        expect((0, PersistedRequests_1.getAll)().length).toBe(1);
        expect((0, PersistedRequests_1.getAll)().at(0)?.command).toBe(types_1.WRITE_COMMANDS.OPEN_APP);
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('SignOut should return a promise with response containing hasOldDotAuthCookies', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        HttpUtils_1.default.xhr
            // This will make the call to OpenApp below return with an expired session code
            .mockImplementationOnce(() => Promise.resolve({
            jsonCode: CONST_1.default.JSON_CODE.SUCCESS,
            hasOldDotAuthCookies: true,
        }));
        const signOutPromise = SessionUtil.signOut();
        expect(signOutPromise).toBeInstanceOf(Promise);
        expect(await signOutPromise).toStrictEqual({
            jsonCode: CONST_1.default.JSON_CODE.SUCCESS,
            hasOldDotAuthCookies: true,
        });
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: false });
        expect((0, PersistedRequests_1.getAll)().length).toBe(0);
    });
    (0, globals_1.test)('SignOutAndRedirectToSignIn should redirect to OldDot when LogOut returns truthy hasOldDotAuthCookies', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        HttpUtils_1.default.xhr
            // This will make the call to OpenApp below return with an expired session code
            .mockImplementationOnce(() => Promise.resolve({
            jsonCode: CONST_1.default.JSON_CODE.SUCCESS,
            hasOldDotAuthCookies: true,
        }));
        const redirectToSignInSpy = globals_1.jest.spyOn(SignInRedirect, 'default').mockImplementation(() => Promise.resolve());
        (0, Session_1.signOutAndRedirectToSignIn)();
        await (0, waitForBatchedUpdates_1.default)();
        expect(asyncOpenURL_1.default).toHaveBeenCalledWith(Promise.resolve(), `${CONFIG_1.default.EXPENSIFY.EXPENSIFY_URL}${CONST_1.default.OLDDOT_URLS.SIGN_OUT}`, true, true);
        expect(redirectToSignInSpy).toHaveBeenCalled();
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.test)('SignOutAndRedirectToSignIn should not redirect to OldDot when LogOut return falsy hasOldDotAuthCookies', async () => {
        await TestHelper.signInWithTestUser();
        await react_native_onyx_1.default.set(ONYXKEYS_1.default.NETWORK, { isOffline: true });
        HttpUtils_1.default.xhr
            // This will make the call to OpenApp below return with an expired session code
            .mockImplementationOnce(() => Promise.resolve({
            jsonCode: CONST_1.default.JSON_CODE.SUCCESS,
        }));
        const redirectToSignInSpy = globals_1.jest.spyOn(SignInRedirect, 'default').mockImplementation(() => Promise.resolve());
        (0, Session_1.signOutAndRedirectToSignIn)();
        await (0, waitForBatchedUpdates_1.default)();
        expect(asyncOpenURL_1.default).not.toHaveBeenCalled();
        expect(redirectToSignInSpy).toHaveBeenCalled();
        globals_1.jest.clearAllMocks();
    });
});
