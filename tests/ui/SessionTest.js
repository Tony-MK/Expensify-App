"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_native_1 = require("@testing-library/react-native");
const expensify_common_1 = require("expensify-common");
const react_native_2 = require("react-native");
const react_native_onyx_1 = require("react-native-onyx");
// eslint-disable-next-line no-restricted-imports, no-restricted-syntax
const AppActions = require("@libs/actions/App");
const Session_1 = require("@libs/actions/Session");
// eslint-disable-next-line no-restricted-imports, no-restricted-syntax
const Session = require("@libs/actions/Session");
const NetworkStore_1 = require("@libs/Network/NetworkStore");
const App_1 = require("@src/App");
const CONST_1 = require("@src/CONST");
const ONYXKEYS_1 = require("@src/ONYXKEYS");
const ROUTES_1 = require("@src/ROUTES");
const reports_1 = require("../utils/collections/reports");
const TestHelper = require("../utils/TestHelper");
const waitForBatchedUpdates_1 = require("../utils/waitForBatchedUpdates");
const waitForBatchedUpdatesWithAct_1 = require("../utils/waitForBatchedUpdatesWithAct");
const waitForNetworkPromises_1 = require("../utils/waitForNetworkPromises");
jest.mock('@libs/Navigation/AppNavigator/usePreloadFullScreenNavigators', () => jest.fn());
const TEST_USER_ACCOUNT_ID_1 = 123;
const TEST_USER_LOGIN_1 = 'test@test.com';
// cspell:disable-next-line
const TEST_AUTH_TOKEN_1 = 'asdfghjkl';
const TEST_USER_ACCOUNT_ID_2 = 456;
const TEST_USER_LOGIN_2 = 'test2@test.com';
// cspell:disable-next-line
const TEST_AUTH_TOKEN_2 = 'zxcvbnm';
jest.setTimeout(60000);
TestHelper.setupApp();
TestHelper.setupGlobalFetchMock();
const report = (0, reports_1.createRandomReport)(7);
function getInitialURL() {
    const params = new URLSearchParams();
    params.set('exitTo', `${ROUTES_1.default.REPORT}/${report.reportID}`);
    params.set('email', TEST_USER_LOGIN_1);
    params.set('shortLivedAuthToken', TEST_AUTH_TOKEN_1);
    const deeplinkUrl = `${CONST_1.default.DEEPLINK_BASE_URL}/transition?${params.toString()}`;
    return deeplinkUrl;
}
describe('Deep linking', () => {
    let lastVisitedPath;
    let originalSignInWithShortLivedAuthToken;
    let originalOpenApp;
    beforeAll(() => {
        originalSignInWithShortLivedAuthToken = Session.signInWithShortLivedAuthToken;
        originalOpenApp = AppActions.openApp;
    });
    beforeEach(() => {
        react_native_onyx_1.default.connect({
            key: ONYXKEYS_1.default.LAST_VISITED_PATH,
            callback: (val) => (lastVisitedPath = val),
        });
        jest.spyOn(Session, 'signInWithShortLivedAuthToken').mockImplementation(() => {
            react_native_onyx_1.default.merge(ONYXKEYS_1.default.CREDENTIALS, {
                login: TEST_USER_LOGIN_1,
                autoGeneratedLogin: expensify_common_1.Str.guid('expensify.cash-'),
                autoGeneratedPassword: expensify_common_1.Str.guid(),
            });
            react_native_onyx_1.default.merge(ONYXKEYS_1.default.ACCOUNT, {
                validated: true,
                isUsingExpensifyCard: false,
            });
            react_native_onyx_1.default.merge(ONYXKEYS_1.default.PERSONAL_DETAILS_LIST, {
                [TEST_USER_ACCOUNT_ID_1]: TestHelper.buildPersonalDetails(TEST_USER_LOGIN_1, TEST_USER_ACCOUNT_ID_1, 'Test'),
            });
            react_native_onyx_1.default.merge(ONYXKEYS_1.default.SESSION, {
                authToken: TEST_AUTH_TOKEN_1,
                accountID: TEST_USER_ACCOUNT_ID_1,
                email: TEST_USER_LOGIN_1,
                encryptedAuthToken: TEST_AUTH_TOKEN_1,
            });
            react_native_onyx_1.default.merge(ONYXKEYS_1.default.NVP_PRIVATE_PUSH_NOTIFICATION_ID, 'randomID');
            return originalSignInWithShortLivedAuthToken(TEST_AUTH_TOKEN_1);
        });
        jest.spyOn(AppActions, 'openApp').mockImplementation(async () => {
            const originalResult = await originalOpenApp();
            await react_native_onyx_1.default.set(`${ONYXKEYS_1.default.COLLECTION.REPORT}${report.reportID}`, report);
            return originalResult;
        });
    });
    afterEach(async () => {
        await react_native_onyx_1.default.clear();
        await (0, waitForNetworkPromises_1.default)();
        jest.clearAllMocks();
        lastVisitedPath = undefined;
        react_native_2.Linking.setInitialURL('');
        (0, NetworkStore_1.setLastShortAuthToken)(null);
    });
    it('should not remember the report path of the last deep link login after signing out and in again', async () => {
        expect((0, Session_1.hasAuthToken)()).toBe(false);
        const url = getInitialURL();
        // User signs in automatically when the app is rendered because of the deep link
        react_native_2.Linking.setInitialURL(url);
        const { unmount } = (0, react_native_1.render)(<App_1.default />);
        await (0, waitForBatchedUpdates_1.default)();
        expect(lastVisitedPath).toBe(`/${ROUTES_1.default.REPORT}/${report.reportID}`);
        expect((0, Session_1.hasAuthToken)()).toBe(true);
        (0, Session_1.signOutAndRedirectToSignIn)();
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        expect((0, Session_1.hasAuthToken)()).toBe(false);
        await TestHelper.signInWithTestUser(TEST_USER_ACCOUNT_ID_2, TEST_USER_LOGIN_2, undefined, TEST_AUTH_TOKEN_2);
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        expect(lastVisitedPath).toBeDefined();
        expect(lastVisitedPath).not.toBe(`/${ROUTES_1.default.REPORT}/${report.reportID}`);
        unmount();
        await (0, waitForBatchedUpdatesWithAct_1.default)();
    });
    it('should not reuse the last deep link and log in again when signing out', async () => {
        expect((0, Session_1.hasAuthToken)()).toBe(false);
        const { unmount: unmount1 } = (0, react_native_1.render)(<App_1.default />);
        await TestHelper.signInWithTestUser(TEST_USER_ACCOUNT_ID_2, TEST_USER_LOGIN_2, undefined, TEST_AUTH_TOKEN_2);
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        expect((0, Session_1.hasAuthToken)()).toBe(true);
        expect((0, NetworkStore_1.getCurrentUserEmail)()).toBe(TEST_USER_LOGIN_2);
        // Unmount so we can prepare the deep link login
        unmount1();
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        const url = getInitialURL();
        // User signs in automatically when the app is remounted because of the deep link.
        // This overrides the previous sign-in.
        react_native_2.Linking.setInitialURL(url);
        const { unmount: unmount2 } = (0, react_native_1.render)(<App_1.default />);
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        expect((0, NetworkStore_1.getCurrentUserEmail)()).toBe(TEST_USER_LOGIN_1);
        (0, Session_1.signOutAndRedirectToSignIn)();
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        // In a failing scenario, remounting triggers the sign-in with the deep link again because it still remembers it.
        // However, we've implemented a fix so that it does not reuse the last deep link.
        unmount2();
        const { unmount: unmount3 } = (0, react_native_1.render)(<App_1.default />);
        await (0, waitForBatchedUpdatesWithAct_1.default)();
        expect((0, Session_1.hasAuthToken)()).toBe(false);
        unmount3();
        await (0, waitForBatchedUpdatesWithAct_1.default)();
    });
});
