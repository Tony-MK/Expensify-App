"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reauthenticate = reauthenticate;
exports.Authenticate = Authenticate;
const react_native_onyx_1 = require("react-native-onyx");
const CONFIG_1 = require("@src/CONFIG");
const CONST_1 = require("@src/CONST");
const ONYXKEYS_1 = require("@src/ONYXKEYS");
const Delegate_1 = require("./actions/Delegate");
const updateSessionAuthTokens_1 = require("./actions/Session/updateSessionAuthTokens");
const SignInRedirect_1 = require("./actions/SignInRedirect");
const ErrorUtils_1 = require("./ErrorUtils");
const Log_1 = require("./Log");
const Network_1 = require("./Network");
const NetworkStore_1 = require("./Network/NetworkStore");
const requireParameters_1 = require("./requireParameters");
let isAuthenticatingWithShortLivedToken = false;
let isSupportAuthTokenUsed = false;
// These session values are only used to help the user authentication with the API.
// Since they aren't connected to a UI anywhere, it's OK to use connectWithoutView()
react_native_onyx_1.default.connectWithoutView({
    key: ONYXKEYS_1.default.SESSION,
    callback: (value) => {
        isAuthenticatingWithShortLivedToken = !!value?.isAuthenticatingWithShortLivedToken;
        isSupportAuthTokenUsed = !!value?.isSupportAuthTokenUsed;
    },
});
function Authenticate(parameters) {
    const commandName = 'Authenticate';
    try {
        (0, requireParameters_1.default)(['partnerName', 'partnerPassword', 'partnerUserID', 'partnerUserSecret'], parameters, commandName);
    }
    catch (error) {
        const errorMessage = error.message;
        Log_1.default.hmmm('Redirecting to Sign In because we failed to reauthenticate', {
            error: errorMessage,
        });
        (0, SignInRedirect_1.default)(errorMessage);
        return Promise.resolve();
    }
    return (0, Network_1.post)(commandName, {
        // When authenticating for the first time, we pass useExpensifyLogin as true so we check
        // for credentials for the expensify partnerID to let users Authenticate with their expensify user
        // and password.
        useExpensifyLogin: parameters.useExpensifyLogin,
        partnerName: parameters.partnerName,
        partnerPassword: parameters.partnerPassword,
        partnerUserID: parameters.partnerUserID,
        partnerUserSecret: parameters.partnerUserSecret,
        twoFactorAuthCode: parameters.twoFactorAuthCode,
        authToken: parameters.authToken,
        shouldRetry: false,
        // Force this request to be made because the network queue is paused when re-authentication is happening
        forceNetworkRequest: true,
        // Add email param so the first Authenticate request is logged on the server w/ this email
        email: parameters.email,
    });
}
/**
 * Reauthenticate using the stored credentials and redirect to the sign in page if unable to do so.
 * @param [command] command name for logging purposes
 * @return returns true if reauthentication was successful, false otherwise.
 */
function reauthenticate(command = '') {
    Log_1.default.hmmm('Reauthenticate - Attempting re-authentication', {
        command,
    });
    // Prevent re-authentication if authentication with shortLiveToken is in progress
    if (isAuthenticatingWithShortLivedToken) {
        Log_1.default.hmmm('Reauthenticate - Authentication with shortLivedToken is in progress. Re-authentication aborted.', {
            command,
            isSupportAuthTokenUsed,
        });
        return Promise.resolve(false);
    }
    // Prevent any more requests from being processed while authentication happens
    (0, NetworkStore_1.setIsAuthenticating)(true);
    Log_1.default.hmmm('Reauthenticate - Waiting for credentials', {
        command,
    });
    return (0, NetworkStore_1.hasReadRequiredDataFromStorage)()
        .then(NetworkStore_1.hasReadShouldUseNewPartnerNameFromStorage)
        .then(() => {
        const credentials = (0, NetworkStore_1.getCredentials)();
        const shouldUseNewPartnerName = (0, NetworkStore_1.getShouldUseNewPartnerName)();
        const partnerName = shouldUseNewPartnerName ? CONFIG_1.default.EXPENSIFY.PARTNER_NAME : CONFIG_1.default.EXPENSIFY.LEGACY_PARTNER_NAME;
        const partnerPassword = shouldUseNewPartnerName ? CONFIG_1.default.EXPENSIFY.PARTNER_PASSWORD : CONFIG_1.default.EXPENSIFY.LEGACY_PARTNER_PASSWORD;
        Log_1.default.info(`Reauthenticate - re-authenticating with ${shouldUseNewPartnerName ? 'new' : 'old'} partner name`);
        Log_1.default.hmmm('Reauthenticate - Starting authentication process', {
            command,
        });
        return Authenticate({
            useExpensifyLogin: false,
            partnerName,
            partnerPassword,
            partnerUserID: credentials?.autoGeneratedLogin,
            partnerUserSecret: credentials?.autoGeneratedPassword,
        }).then((response) => {
            if (!response) {
                return false;
            }
            Log_1.default.hmmm('Reauthenticate - Processing authentication result', {
                command,
            });
            if (response.jsonCode === CONST_1.default.JSON_CODE.UNABLE_TO_RETRY) {
                // When a fetch() fails due to a network issue and an error is thrown we won't log the user out. Most likely they
                // have a spotty connection and will need to retry reauthenticate when they come back online. Error so it can be handled by the retry mechanism.
                throw new Error('Unable to retry Authenticate request');
            }
            // If authentication fails and we are online then log the user out
            if (response.jsonCode !== 200) {
                const errorMessage = (0, ErrorUtils_1.getAuthenticateErrorMessage)(response);
                (0, NetworkStore_1.setIsAuthenticating)(false);
                Log_1.default.hmmm('Redirecting to Sign In because we failed to reauthenticate', {
                    command,
                    error: errorMessage,
                });
                (0, SignInRedirect_1.default)(errorMessage);
                return false;
            }
            // If we reauthenticate due to an expired delegate token, restore the delegate's original account.
            // This is because the credentials used to reauthenticate were for the delegate's original account, and not for the account they were connected as.
            if ((0, Delegate_1.isConnectedAsDelegate)()) {
                Log_1.default.info('Reauthenticate while connected as a delegate. Restoring original account.');
                (0, Delegate_1.restoreDelegateSession)(response);
                return true;
            }
            // Update authToken in Onyx and in our local variables so that API requests will use the new authToken
            (0, updateSessionAuthTokens_1.default)(response.authToken, response.encryptedAuthToken);
            // Note: It is important to manually set the authToken that is in the store here since any requests that are hooked into
            // reauthenticate .then() will immediate post and use the local authToken. Onyx updates subscribers lately so it is not
            // enough to do the updateSessionAuthTokens() call above.
            (0, NetworkStore_1.setAuthToken)(response.authToken ?? null);
            // The authentication process is finished so the network can be unpaused to continue processing requests
            (0, NetworkStore_1.setIsAuthenticating)(false);
            Log_1.default.hmmm('Reauthenticate - Re-authentication successful', {
                command,
            });
            return true;
        });
    });
}
